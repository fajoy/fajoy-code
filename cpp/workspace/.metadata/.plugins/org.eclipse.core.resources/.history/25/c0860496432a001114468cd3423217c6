#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netdb.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <map>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>
using namespace std;

fd_set rfds_src;
fd_set wfds_src;
fd_set rfds;
fd_set wfds;
typedef struct reqdata {
	char h1[255];
	char h2[255];
	char h3[255];
	char h4[255];
	char h5[255];
	char p1[5];
	char p2[5];
	char p3[5];
	char p4[5];
	char p5[5];
	char f1[255];
	char f2[255];
	char f3[255];
	char f4[255];
	char f5[255];
} reqdata;
char *query;
reqdata req;
void init_req() {
	query = getenv("QUERY_STRING");
	if (query == NULL) {
		char
				testquery[] =
						"h1=127.0.0.1&p1=8001&f1=t1.txt&h2=&p2=&f2=&h3=&p3=&f3=&h4=&p4=&f4=&h5=&p5=&f5=";
		query = testquery;
	}
	memset(&req, 0, sizeof(req));
	sscanf(query, "h1=%[^&]&p1=%[^&]&f1=%[^&]&"
		"h2=%[^&]&p2=%[^&]&f2=%[^&]&"
		"h3=%[^&]&p3=%[^&]&f3=%[^&]&"
		"h4=%[^&]&p4=%[^&]&f4=%[^&]&"
		"h5=%[^&]&p5=%[^&]&f5=%[^&]", &req.h1[0], &req.p1[0], &req.f1[0],
			&req.h2[0], &req.p2[0], &req.f2[0], &req.h3[0], &req.p3[0],
			&req.f3[0], &req.h4[0], &req.p4[0], &req.f4[0], &req.h5[0],
			&req.p5[0], &req.f5[0]);

}

class SerCon {
public:
	int index;
	char host[255];
	int port;
	char filename[255];
	int con_fd;
	bool is_con;
	bool is_openfile;
	string recv_buf;
	string send_buf;
	int mode;
	timeval send_t;
	SerCon() {

	}
	void initobg(int i) {

		index = i;
		mode = 1;
		is_openfile = false;
		is_con = false;
		memset(host, 0, sizeof(host));
		memset(filename, 0, sizeof(filename));
		port = 0;
		recv_buf = "";
		send_buf = "";
		gettimeofday(&send_t, NULL);
		send_t.tv_sec += 2;
	}
	FILE *fp;
	void parse(char *, char *, char *);

	string str_replace(string str, string oldstr, string newstr) {
		int i = str.find(oldstr);
		while (i != -1) {
			str.replace(i, oldstr.length(), newstr);
			i = str.find(oldstr);
		}
		return str;
	}
	void js(const char *line) {
		string tmp = line;
		tmp = str_replace(tmp, " ", "&nbsp;");
		tmp = str_replace(tmp, "<", "&lt;");
		tmp = str_replace(tmp, ">", "&gt;");
		tmp = str_replace(tmp, "\r", "");
		tmp = str_replace(tmp, "\n", "<br />");
		tmp = str_replace(tmp, "\"", "\\\"");
		printf(
				"<script type='text/javascript'>document.all['m%d'].innerHTML += \"%s\";</script>\n",
				index, tmp.c_str());
		fflush(stdout);
	}

	void openfile() {
		try {
			//fflush(stdout);
			//string path=
			fp = fopen(filename, "r");
			is_openfile = true;
			readfile();
		} catch (...) {

		}
	}
	int readfile() {
		if (is_openfile) {
			char buf[1024];
			bzero(buf, sizeof(buf));
			if (fgets(buf, sizeof(buf), fp) != NULL) {
				//int len = strlen(buf);
				send_buf += buf;
				return 1;
			} else {
				is_openfile = false;
				//write_buf = "";
				return 0;
			}
		}

		return 0;
	}
	int senddata() {
		int len = send(con_fd, send_buf.c_str(), send_buf.length(), 0);
		if (len > 0) {
			gettimeofday(&send_t, NULL);
			send_t.tv_usec += 3000;
			if (send_t.tv_usec > 10000) {
				send_t.tv_sec += send_t.tv_usec/10000;
				send_t.tv_usec %= 10000;
			}

			//cout << write_buf.substr(0, len) << endl;
			js(send_buf.c_str());
			send_buf.erase(0, len);
		}
		return len;
	}
	int recvdata() {
		char buf[1024];
		bzero(buf, sizeof(buf));
		int len = recv(con_fd, buf, sizeof(buf), 0);
		if (len > 0) {
			recv_buf += buf;
		}

		flushdata();
		return len;
	}

	int flushdata() {
		if (recv_buf.length() > 0) {
			js(recv_buf.c_str());
			recv_buf.erase(0, recv_buf.length());
		}
	}
};

void SerCon::parse(char *shost, char* sport, char *sfilename) {
	strcpy(host, shost);
	strcpy(filename, sfilename);
	port = atoi(sport);
	is_con = false;
}

SerCon sc[5];
sockaddr_in dest[5];
map<int, SerCon*> clients;
void connect(int i) {

	int con_fd = socket(AF_INET, SOCK_STREAM, 0);

	bzero(&dest[i], sizeof(dest[i]));
	dest[i].sin_family = AF_INET;

	struct hostent *server = (struct hostent *) gethostbyname(sc[i].host);
	dest[i].sin_addr.s_addr = inet_addr(sc[i].host);
	dest[i].sin_addr = *((struct in_addr *) server->h_addr);
	//dest[i].sin_addr.s_addr =inet_addr(sc[i].host);
	dest[i].sin_port = htons(sc[i].port);

	if (connect(con_fd, (struct sockaddr *) &dest[i], sizeof(dest[i])) != -1) {
		//cout << "conn "<< i <<sc.host<<sc.port <<sc.filename<<endl;
		//fflush(stdout);
		clients[sc[i].con_fd] = &sc[i];
		sc[i].con_fd = con_fd;
		sc[i].is_con = true;
		int flag;
		flag = fcntl(con_fd, F_GETFL, 0);
		fcntl(con_fd, F_SETFL, flag | O_NONBLOCK);
	}

	/*
	 server = gethostbyname(sc.host);
	 bzero((char *) &sc.serv_addr, sizeof(sc.serv_addr));
	 serv_addr.sin_family = AF_INET;
	 bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, sc.server._length);
	 serv_addr.sin_port = htons(portno);*/
}
void print_table_row() {
	int i = 0;
	printf("<tr>\n");
	for (i = 0; i < 5; i++) {
		if (sc[i].is_con) {
			printf("<td>%s</td>\n", sc[i].host);
		}
	}
	printf("</tr>\n");

	printf("<tr>\n");
	for (i = 0; i < 5; i++) {
		if (sc[i].is_con) {
			printf("<td valign=\"top\" id=\"m%d\"></td>\n", i);
		}
	}
	printf("</tr>");

}
void begin_html() {
	printf("<html>\n"
		"<head>\n"
		"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf8\" />\n"
		"</head>\n"
		"<body bgcolor=#336699>\n"
		"<font face=\"Courier New\" size=2 color=#FFFF99>\n"
		"<table width=\"800\" border=\"1\">\n");
	print_table_row();
	printf("</table>");
}
void end_html() {
	printf("</font>\n"
		"</body>\n"
		"</html>\n");
}

void initSc() {
	try {
		sc[0].initobg(0);
		sc[0].parse(&req.h1[0], &req.p1[0], &req.f1[0]);
		sc[1].initobg(1);
		sc[1].parse(&req.h2[0], &req.p2[0], &req.f2[0]);
		sc[2].initobg(2);
		sc[2].parse(&req.h3[0], &req.p3[0], &req.f3[0]);
		sc[3].initobg(3);
		sc[3].parse(&req.h4[0], &req.p4[0], &req.f4[0]);
		sc[4].initobg(4);
		sc[4].parse(&req.h5[0], &req.p5[0], &req.f5[0]);
	} catch (...) {
		//cout << "parse error!";
	}

}
void con_Sc() {
	int i = 0;
	for (i = 0; i < 5; i++) {
		bool hasHost = strlen(sc[i].host);
		bool hasFile = strlen(sc[i].filename);
		bool hasPort = sc[i].port != 0;
		//cout << "conn "<< i <<sc[i].host<<sc[i].port <<sc[i].filename<<endl;
		//fflush(stdout);
		try {
			if (hasHost && hasFile && hasPort) {
				connect(i);
				sc[i].openfile();
				//cout << i << endl;
			}
		} catch (...) {
			//cout << "parse error!";
		}
	}
}
void closeAll() {
	fflush(stdout);
	int fd = FD_SETSIZE;
	for (fd; fd > 0; fd--)
		close(fd);
}

void handerSelect() {
	int i = 0;
	for (i = 0; i < 5; i++) {

		if (sc[i].is_con) {
			int con_fd = sc[i].con_fd;
			if (FD_ISSET(con_fd, &rfds) || FD_ISSET(con_fd, &wfds)) {
				int error = 0;
				int len = 0;

				int opt = getsockopt(con_fd, SOL_SOCKET, SO_ERROR,
						(void *) &error, (socklen_t*) &len);
				if (opt < 0 || error != 0) {
					// non-blocking connect failed
					FD_CLR(con_fd, &rfds_src);
					FD_CLR(con_fd, &wfds_src);
					sc[i].is_con = false;
					continue;
				}

				if (FD_ISSET(con_fd, &wfds)) {
					timeval tv;
					gettimeofday(&tv, NULL);
					if (tv.tv_sec >= sc[i].send_t.tv_sec) {
						if (tv.tv_usec > sc[i].send_t.tv_usec) {
							sc[i].senddata();
							gettimeofday(&sc[i].send_t, NULL);
							sc[i].send_t.tv_sec += 1;
							if (sc[i].mode < 2)
								sc[i].mode = 0;
						}

					}
					//FD_CLR(con_fd,&wfds_src);
					//FD_SET(con_fd,&rfds_src);
					if (sc[i].send_buf.length() == 0)
						sc[i].readfile();
				}
				if (FD_ISSET(con_fd, &rfds)) {
					int len = sc[i].recvdata();
					sc[i].flushdata();
					if (sc[i].mode < 2)
						sc[i].mode = 1;
					//FD_CLR(con_fd,&rfds_src);
					//FD_SET(con_fd,&wfds_src);
				}

				if (sc[i].send_buf.length() == 0 && sc[i].recv_buf.length()
						== 0) {
					sc[i].is_con = false;
					sc[i].mode = 2;
					FD_CLR(con_fd, &rfds_src);
					FD_CLR(con_fd, &wfds_src);
					shutdown(con_fd, SHUT_RDWR);
				}

			}

		}

		//		cout << "c" << sc[i].is_con << "m" << sc[i].mode << "o"
		//				<< sc[i].is_openfile << "wl" << sc[i].write_buf.length()
		//				<< "rl" << sc[i].read_buf.length() << endl;
	}

}

void select_con() {
	int i = 0;
	bzero(&rfds_src, sizeof(rfds_src));
	bzero(&wfds_src, sizeof(wfds_src));
	for (i = 0; i < 5; i++) {
		if (sc[i].is_con) {
			FD_SET(sc[i].con_fd,&rfds_src);
			FD_SET(sc[i].con_fd,&wfds_src);
		}
	}

	while (sc[0].is_con || sc[1].is_con || sc[2].is_con || sc[3].is_con
			|| sc[4].is_con) {
		memcpy(&rfds, &rfds_src, sizeof(rfds_src));
		memcpy(&wfds, &wfds_src, sizeof(wfds_src));
		select(64, &rfds, &wfds, (fd_set*) 0, (struct timeval*) 4);
		handerSelect();
	}

}

int main(int argc, char* argv[], char *envp[]) {
	init_req();

	initSc();
	con_Sc();
	//char tmp[1024];
	//read(0, tmp, 1024);
	//flag = fcntl(1, F_GETFL, 0);
	//fcntl(1, F_SETFL, flag | O_NONBLOCK);
	// printf("HTTP/1.1 200 OK\n");


	//printf("Accept-Asynchronous: response\n");
	//printf("Content-length:4096\n");
	// printf("Cache-Control: max-age=0\n");
	printf("Content-type: text/html\n");

	// printf("Content-type: text/plain\n");
	printf("\n");

	fflush(stdout);
	begin_html();

	select_con();

	/*
	 for (int j = 0; j < 5; j++) {
	 for (int i = 0; i < 1000; i++) {
	 char tmp[20];
	 memset(tmp, 0, sizeof(tmp));
	 if (i % 10 == 0)
	 sprintf(tmp, "%d<br/>", i);
	 else
	 sprintf(tmp, "%d", i);
	 sc[j].js(j, &tmp[0]);
	 fflush(stdout);
	 usleep(10000);
	 }

	 }
	 */
	//sc[0].show();

	end_html();
	closeAll();
	return 0;
}
